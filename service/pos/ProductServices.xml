<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="get" noun="ProductInfo">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="productStoreId"/>
            <parameter name="vendorPartyId"/>
            <parameter name="priceUomId"/>
            <parameter name="locale" default="ec.user.locale?.toString()"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productInfoMap" type="Map" />
        </out-parameters>
        <actions>
            <set field="productInfoMap" from="[:]"/>
            <entity-find-one entity-name="mantle.product.Product" value-field="productData">
                <field-map field-name="productId"/>
            </entity-find-one>

            <!--fetch barcode of product-->
            <entity-find entity-name="mantle.product.ProductIdentification" list="identificationList">
                <econdition field-name="productId" from="productData.productId"/>
            </entity-find>
            <iterate list="identificationList" entry="identification">
                <if condition="identification.productIdTypeEnumId == 'PidtBarcode'">
                    <set field="barcode" from="identification.idValue"/>
                </if>
            </iterate>

            <!--fetch description of product-->
            <entity-find entity-name="mantle.product.ProductContent" list="productContentList">
                <econdition field-name="productId" from="productData.productId"/>
                <date-filter/>
            </entity-find>
            <set field="descriptionLocation" from="(productContentList.cloneList().filterByAnd([productContentTypeEnumId: 'PcntDescription']))[0]?.contentLocation"/>
            <if condition="descriptionLocation">
                <set field="description" from="ec.resource.getLocationText(descriptionLocation, true)"/>
            </if>

            <!--prepare stock map of product-->
            <entity-find-one entity-name="mantle.product.asset.AssetAndDetail" value-field="asset">
                <field-map field-name="productId" from="productData.productId"/>
                <field-map field-name="statusId" from="'AstAvailable'"/>
                <field-map field-name="assetTypeEnumId" from="'AstTpInventory'"/>
            </entity-find-one>
            <set field="stockInfo" from="[:]"/>
            <set field="stockInfo.item_id" from="productData.productId"/>
            <set field="stockInfo.product_id" from="productData.productId"/>
            <set field="stockInfo.stock_id" from="asset?.assetId"/>
            <if condition="asset?.hasQuantity == 'Y'">
                <set field="stockInfo.qty" from="asset.quantityOnHandTotal ? asset.quantityOnHandTotal : 0" type="Integer"/>
                <set field="stockInfo.is_in_stock" value="true" type="Boolean"/>
                <else>
                    <set field="stockInfo.qty" value="0" type="Integer"/>
                    <set field="stockInfo.is_in_stock" value="false" type="Boolean"/>
                </else>
            </if>
            <set field="stockInfo.is_qty_decimal" value="false" type="Boolean"/>
            <set field="stockInfo.show_default_notification_message" value="false" type="Boolean"/>
            <set field="stockInfo.use_config_min_qty" value="true" type="Boolean"/>
            <set field="stockInfo.min_qty" value="0" type="Integer"/>
            <set field="stockInfo.use_config_min_sale_qty" value="1" type="Integer"/>
            <set field="stockInfo.min_sale_qty" value="1" type="Integer"/>
            <set field="stockInfo.use_config_max_sale_qty" value="true" type="Boolean"/>
            <set field="stockInfo.max_sale_qty" value="10000" type="Integer"/>
            <set field="stockInfo.use_config_backorders" value="true" type="Boolean"/>

            <entity-find-count entity-name="mantle.product.issuance.AssetIssuance" count-field="orders">
                <econdition field-name="productId" from="productData.productId"/>
            </entity-find-count>
            <set field="stockInfo.backorders" from="orders"/>
            <set field="stockInfo.use_config_notify_stock_qty" value="true" type="Boolean"/>
            <set field="stockInfo.notify_stock_qty" value="1" type="Integer"/>
            <set field="stockInfo.use_config_qty_increments" value="true" type="Boolean"/>
            <set field="stockInfo.qty_increments" value="0" type="Integer"/>
            <set field="stockInfo.use_config_enable_qty_inc" type="Boolean" value="true"/>
            <set field="stockInfo.enable_qty_increments" value="false" type="Boolean"/>
            <set field="stockInfo.use_config_manage_stock" value="true" type="Boolean"/>
            <set field="stockInfo.manage_stock" value="true" type="Boolean"/>
            <set field="stockInfo.low_stock_date" default-value="null"/>
            <set field="stockInfo.is_decimal_divided" value="false" type="Boolean"/>
            <set field="stockInfo.stock_status_changed_auto" value="0" type="Integer"/>

            <!--fetch tax rate and tax rate-->
            <entity-find-one entity-name="mantle.product.ProductAssoc" value-field="productAssocData">
                <field-map field-name="toProductId" from="productData.productId"/>
                <field-map field-name="productAssocTypeEnumId" value="PatVariant"/>
            </entity-find-one>

            <if condition="productAssocData">
                <entity-find entity-name="mantle.product.category.ProductCategoryAndMember" list="productCategoryList">
                    <econdition field-name="productId" from="productAssocData.productId"/>
                    <date-filter/>
                </entity-find>
                <iterate list="productCategoryList" entry="productCategory">
                    <if condition="productCategory.productCategoryTypeEnumId == 'PctHSN'">
                        <entity-find-one entity-name="mantle.product.category.ProductCategoryRollup" value-field="productCategoryRollupData">
                            <field-map field-name="productCategoryId" from="productCategory.productCategoryId"/>
                        </entity-find-one>

                        <entity-find-one entity-name="pickerp.CategoryTaxRate" value-field="categoryTaxRateData">
                            <field-map field-name="taxCategoryId" from="productCategoryRollupData.parentProductCategoryId"/>
                        </entity-find-one>
                        <set field="taxRate" from="categoryTaxRateData?.taxRate"/>
                        <set field="taxRateType" from="categoryTaxRateData?.taxRateEnumId"/>
                    </if>
                </iterate>
            </if>

            <!--fetch price of Product-->
            <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceMap"
                          in-map="[productId:productData.productId, priceUomId:priceUomId, productStoreId:productStoreId,
                        vendorPartyId:vendorPartyId, customerPartyId:customerPartyId]"/>

            <!--prepare response productInfoMap-->
            <set field="productInfoMap.productId" from="productData.productId" />
            <set field="productInfoMap.barcode" from="barcode" default-value="null" />
            <set field="productInfoMap.name" from="productData.productName" />
            <set field="productInfoMap.description" from="description" default-value="null"/>
            <set field="productInfoMap.price" from="ec.l10n.format(priceMap.price, '##,#####0.00')" type="BigDecimal"/>
            <set field="productInfoMap.stock" from="stockInfo"/>
            <set field="productInfoMap.taxRate" from="taxRate" default-value="0" type="Integer"/>
            <set field="productInfoMap.taxRateType" from="taxRateType" default-value="null"/>
            <service-call name="pos.ProductServices.get#ProductQuantity" in-map="[productId: productData?.productId]" out-map="inventoryMap"/>
            <set field="productInfoMap.quantity" from="inventoryMap.productQuantity" default-value="0" type="Integer"/>
        </actions>
    </service>


    <!-- TODO: this service is not adequately constrained, will get inventory from all facilities, owners, pools, etc; see AssetServices.get#AvailableInventory -->
    <service verb="get" noun="ProductQuantity">
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productQuantity"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.AssetAndDetail" value-field="asset">
                <field-map field-name="productId" from="productId"/>
                <field-map field-name="statusId" from="'AstAvailable'"/>
                <field-map field-name="assetTypeEnumId" from="'AstTpInventory'"/>
            </entity-find-one>
            <if condition="!asset">
                <return message="Asset not found"/>
            </if>
            <set field="productQuantity" from="asset.quantityOnHandTotal ? asset.quantityOnHandTotal : 0"/>
        </actions>
    </service>

    <!-- TODO: this service is not adequately constrained, will get inventory regardless of owner, pool, etc; see AssetServices.get#AvailableInventory -->
    <service verb="find" noun="ProductAvailability">
        <description>
            Create collection of product ids with availability flag.
        </description>
        <in-parameters>
            <parameter name="productStoreId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productAvailability"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
            <set field="inventoryFacilityIds" type="List" from="[productStore.inventoryFacilityId]"/>
            <entity-find entity-name="mantle.product.store.ProductStoreFacility" list="productStoreFacilities">
                <econdition field-name="productStoreId"/>
                <date-filter/>
            </entity-find>
            <iterate list="productStoreFacilities" entry="productStoreFacility">
                <set field="inventoryFacilityIds" from="inventoryFacilityIds + productStoreFacility.facilityId"/>
            </iterate>
            <entity-find entity-name="mantle.product.asset.AssetSummaryView" list="productAssetSumList">
                <econdition field-name="productAssetTypeEnumId" value="AstTpInventory"/>
                <econdition field-name="facilityId" operator="in" from="inventoryFacilityIds"/>
                <having-econditions combine="or">
                    <econdition field-name="quantityOnHandTotal" operator="not-equals" from="0.0"/>
                    <econdition field-name="availableToPromiseTotal" operator="not-equals" from="0.0"/>
                </having-econditions>
                <select-field field-name="productId"/>
                <select-field field-name="availableToPromiseTotal"/>
            </entity-find>
            <set field="productAvailability" from="[:]"/>
            <iterate list="productAssetSumList" entry="assetSum">
                <script>
                    productAvailability.put(assetSum.productId, assetSum.availableToPromiseTotal>0)
                </script>
            </iterate>
        </actions>
    </service>

    <service verb="get" noun="SortedProductList">
        <in-parameters>
            <parameter name="productCategoryId"/>
            <parameter name="productStoreId"/>
            <parameter name="orderBy" default-value="${ec.web.sessionAttributes.defaultSorting}"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productList"/>
        </out-parameters>
        <actions>
            <script>
                import org.moqui.entity.EntityCondition
                import org.moqui.entity.EntityConditionFactory
            </script>
            <if condition="orderBy=='popularity'">
                <then>
                    <script>
                        def cal = ec.user.nowCalendar
                        cal.add(Calendar.YEAR, -1)
                        def yearAgo = new Timestamp(cal.getTimeInMillis())
                    </script>
                    <entity-find entity-name="ProductCategoryProductOrderItemSort" list="productList">
                        <econdition field-name="productCategoryId"/>
                        <econdition field-name="lastUpdatedStamp" operator="greater" from="yearAgo" or-null="true"/>
                        <date-filter/>
                        <date-filter thru-field-name="salesDiscontinuationDate"/>
                        <select-field field-name="productId"/>
                        <select-field field-name="productTypeEnumId"/>
                        <select-field field-name="productName"/>
                        <select-field field-name="orderedTotal"/>
                        <order-by field-name="-orderedTotal,sequenceNum,productName"/>
                    </entity-find>
                    <script><![CDATA[
                        def sortedList = [] as List
                        productList.each{ product ->
                            if ('PtVirtual' == product.productTypeEnumId) {
                                def virtualSumQuantity = 0
                                // sum of ordered variants
                                def variants = ec.entity.find("mantle.product.ProductAssoc")
                                        .condition([productId:product.productId, productAssocTypeEnumId:'PatVariant'])
                                        .conditionDate("fromDate", "thruDate", ec.user.nowTimestamp).list();
                                if (variants) {
                                    variants.each{variant ->
                                        def variantOrderItems = ec.entity.find("mantle.order.OrderItem")
                                                .condition('lastUpdatedStamp', 'greater-than', yearAgo)
                                                .condition([productId:variant.toProductId]).list()
                                        variantOrderItems.each { orderItem ->
                                            virtualSumQuantity += orderItem.quantity
                                        }
                                    }
                                }
                                product.orderedTotal = virtualSumQuantity
                            }
                            if (!product.orderedTotal) {
                                product.orderedTotal = 0
                            }
                            sortedList.add(product)
                        }
                        sortedList.sort({-it.orderedTotal})
                        productList = sortedList
                        ec.web.sessionAttributes.defaultSorting = orderBy
                    ]]></script>
                    <return/>
                </then>
            </if>
            <if condition="orderBy=='price-asc' || orderBy=='price-desc'">
                <then>
                    <set field="orderByField" value="price"/>
                    <if condition="orderBy=='price-desc'">
                        <set field="orderByField" value="-price"/>
                    </if>
                    <entity-find entity-name="ProductCategoryProductPriceSort" list="productList">
                        <econdition field-name="productCategoryId"/>
                        <econdition field-name="variantProductStoreId" from="productStoreId" or-null="true"/>
                        <econditions combine="or">
                            <econdition field-name="priceTypeEnumId" operator="in" from="['PptList','PptCurrent']"/>
                            <econdition field-name="variantPriceTypeEnumId" operator="in" from="['PptList','PptCurrent']"/>
                        </econditions>
                        <econditions combine="or">
                            <econdition field-name="pricePurposeEnumId" value="PppPurchase"/>
                            <econdition field-name="variantPricePurposeEnumId" value="PppPurchase"/>
                        </econditions>
                        <date-filter/>
                        <date-filter from-field-name="priceFromDate" thru-field-name="priceThruDate"/>
                        <date-filter from-field-name="variantPriceFromDate" thru-field-name="variantPriceThruDate"/>
                        <date-filter thru-field-name="salesDiscontinuationDate"/>
                        <order-by field-name="${orderByField}"/>
                    </entity-find>
                    <script>
                        // list of products are postprocessed to remove list prices if a current price exists
                        def currentPriceProductIds = [] as Set
                        productList.each{product ->
                            if (product.priceTypeEnumId == 'PptCurrent' || product.variantPricePurposeEnumId == 'PptCurrent') {
                                if (!currentPriceProductIds.contains(product.productId)) {
                                    currentPriceProductIds.add(product.productId)
                                }
                            }
                        }
                        def sortedList = [] as List
                        productList.each{product ->
                            if ((product.priceTypeEnumId == 'PptList' || product.variantPricePurposeEnumId == 'PptList')) {
                                if (!currentPriceProductIds.contains(product.productId)) {
                                    sortedList.add(product)
                                }
                            } else {
                                sortedList.add(product)
                            }
                        }
                        productList = sortedList
                        ec.web.sessionAttributes.defaultSorting = orderBy
                    </script>
                    <return/>
                </then>
            </if>

            <!-- default sorting -->
            <entity-find entity-name="ProductCategoryMemberProduct" list="productList">
                <econdition field-name="productCategoryId"/>
                <date-filter/>
                <date-filter thru-field-name="salesDiscontinuationDate"/>
                <order-by field-name="sequenceNum,productName"/>
            </entity-find>
            <if condition="orderBy=='default'">
                <script>ec.web.sessionAttributes.remove('defaultSorting')</script>
            </if>
        </actions>
    </service>

    <service verb="find" noun="ProductContent">
        <description>
            Try to find ProductContent record of a specified type the product. If it is not found then either
            product does not have a content of this type or this is a variant and we should check its virtual
            parent for the same.
        </description>
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="productContentTypeEnumId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productContent" type="EntityValue"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.product.ProductContent" list="productContentList" cache="true">
                <econdition field-name="productContentTypeEnumId"/>
                <econdition field-name="productId"/>
                <date-filter/>
            </entity-find>
            <if condition="productContentList">
                <set field="productContent" from="productContentList[0]"/>
                <return/>
            </if>
            <!-- either no content of this type or productId refers to variant of a virtual product -->
            <service-call name="pos.ProductServices.get#CatalogProductId" in-map="context" out-map="prodIdRes"/>
            <if condition="productId != prodIdRes.productId">
                <entity-find entity-name="mantle.product.ProductContent" list="productContentList" cache="true">
                    <econdition field-name="productContentTypeEnumId"/>
                    <econdition field-name="productId" from="prodIdRes.productId"/>
                    <date-filter/>
                </entity-find>
                <if condition="productContentList">
                    <set field="productContent" from="productContentList[0]"/>
                </if>
            </if>
        </actions>
    </service>

    <service verb="get" noun="ProductVariantsDisplayInfo">
        <in-parameters>
            <parameter name="productId">
                <description>Only id of a virtual product make sense to get relevant data.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="featureType"></parameter>
            <parameter name="variantOptions" type="Map">
                <description>
                    A map where key is feature type (Enumeration) and value is another map
                    with productId, description and price data exactly as it returned by get#ProductPrice.
                </description>
            </parameter>
            <parameter name="minimalPrice" type="BigDecimal">
                <description>Minimal price among all variants.</description>
            </parameter>
            <parameter name="maximalPrice" type="BigDecimal">
                <description>Maximal price among all variants.</description>
            </parameter>
            <parameter name="isDiscounted" type="Boolean">
                <description>We use this flag in UI to emphasis discounted products if they are variants</description>
            </parameter>
            <parameter name="listFeatures"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.Product" value-field="product"/>

            <set field="variantOptions" type="NewMap" value="null"/>
            <script>variantOptions = new HashMap()</script>
            <set field="minimalPrice" type="BigDecimal" value="0"/>
            <set field="maximalPrice" type="BigDecimal" value="0"/>
            <set field="isDiscounted" type="Boolean" value="false"/>

            <service-call name="mantle.product.PriceServices.get#ProductPrice" in-map="context" out-map="mainPriceSet" />

            <if condition="product &amp;&amp; product.productTypeEnumId == 'PtVirtual'">
                <entity-find entity-name="mantle.product.ProductAssocAndToFeatureAppl" list="assocs">
                    <econdition field-name="productAssocTypeEnumId" value="PatVariant"/>
                    <econdition field-name="applTypeEnumId" operator="in" value="PfatDistinguishing, PfatStandard" />
                    <econdition field-name="productId" from="product.productId"/>
                    <date-filter/>
                </entity-find>
                <set field="listFeatures" type="NewMap" value="null"/>
                <script>listFeatures = new HashMap()</script>
                <iterate list="assocs" entry="variantProductAssoc">
                    <!-- find variant price first -->
                    <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceSet"
                            in-map="context + [productId:variantProductAssoc.toProductId]" />
                    <entity-find entity-name="mantle.product.feature.ProductFeatureAndAppl" list="features">
                        <date-filter/>
                        <econdition field-name="productId" from="variantProductAssoc.toProductId"/>
                        <econdition field-name="productFeatureId" from="variantProductAssoc.productFeatureId"/>
                    </entity-find>

                    <!-- we return map keyed by feature type and should find the proper value for the assoc -->
                    <entity-find-one entity-name="mantle.product.feature.ProductFeature" value-field="productFeature" cache="true">
                        <field-map field-name="productFeatureId" from="variantProductAssoc.productFeatureId"/>
                    </entity-find-one>
                    <service-call name="pos.ProductServices.get#ProductQuantity" out-map="productQuantity" in-map="[productId:variantProductAssoc.toProductId]"/>
                    <entity-find-one entity-name="moqui.basic.Enumeration" value-field="featureType" cache="true">
                        <field-map field-name="enumId" from="productFeature.productFeatureTypeEnumId"/>
                    </entity-find-one>
                    <set field="item" from="[enumId:featureType.enumId, enumTypeId:featureType.enumTypeId,
                        description:featureType.description, lastUpdatedStamp:featureType.lastUpdatedStamp]"/>
                    <set field="content" from="[productFeatureTypeEnumId:productFeature.productFeatureTypeEnumId,
                        description:featureType.description]"/>
                    <script><![CDATA[
                        selectedPrices = (priceSet.price != null && priceSet != 0) ? priceSet : mainPriceSet
                        // we use this flag in UI to emphasis discounted products but important to know if any of variants of discounted
                        if (!isDiscounted) {
                            isDiscounted = (selectedPrices.price && selectedPrices.listPrice) ? selectedPrices.price < selectedPrices.listPrice : false
                        }

                        def featureSet = listFeatures.get(content)
                        if (!featureSet) {
                            listFeatures.put(content,
                            [[productFeatureId:productFeature.productFeatureId,
                            productFeatureTypeEnumId:productFeature.productFeatureTypeEnumId,
                            description:productFeature.description, abbrev:productFeature.abbrev, price:selectedPrices]])
                        } else {
                            boolean isItemInList = false
                            for(int i=0; i < featureSet.size(); i++) {
                                if(featureSet.get(i).productFeatureId.equals(productFeature.productFeatureId)) {
                                    isItemInList = true
                                    break
                                }
                            }
                            if(!isItemInList) {
                                featureSet.add([productFeatureId:productFeature.productFeatureId,
                                productFeatureTypeEnumId:productFeature.productFeatureTypeEnumId,
                                description:productFeature.description, abbrev:productFeature.abbrev, price:selectedPrices])
                            }
                        }

                        def optionSet = variantOptions.get(item)
                        if (!optionSet) {
                            variantOptions.put(item, [[productId: variantProductAssoc.toProductId, description:productFeature.description, quantity: productQuantity.productQuantity,
                            prices:selectedPrices]])
                        } else {
                            optionSet.add([productId: variantProductAssoc.toProductId, description:productFeature.description, quantity: productQuantity.productQuantity,
                            prices:selectedPrices])
                        }
                        priceSet = null
                    ]]></script>
                </iterate>

                <!-- sort variants by price and store minimal price -->
                <script><![CDATA[
                    variantOptions.each{k, v ->
                        Collections.sort(v, new Comparator<Map>() {
                            int compare(Map m1, Map m2) {
                                def price1 = m1.prices.price?:0
                                def price2 = m2.prices.price?:0
                                return price1.compareTo(price2)
                            }
                        })
                        minimalPrice = v.get(0).prices.price
                        maximalPrice = v.get(v.size() - 1).prices.price
                    }
                ]]></script>

                <else>
                    <set field="minimalPrice" type="BigDecimal" from="mainPriceSet.price"/>
                    <set field="maximalPrice" type="BigDecimal" from="mainPriceSet.price"/>
                </else>
            </if>
        </actions>
    </service>

    <service verb="create" noun="ProductReview">
        <in-parameters>
            <parameter name="productId"/>
            <parameter name="productRating"/>
            <parameter name="productReview"/>
        </in-parameters>
        <actions>
            <service-call name="create#mantle.product.ProductReview"
                in-map="context + [userId:(ec.user.userId ?: '_NA_'), statusId:'PrvwApproved',
                postedAnonymous:(ec.user.userId ? 'N' : 'Y'), postedDateTime:ec.user.nowTimestamp]"/>
        </actions>
    </service>

    <service verb="get" noun="ProductReviews">
        <in-parameters>
            <parameter name="productId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productReviewList" type="List"><parameter name="review" type="Map"/></parameter>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.product.ProductReview" list="productReviewList">
                <econdition field-name="productId"/>
                <econdition field-name="statusId" value="PrvwApproved"/>
            </entity-find>
        </actions>
    </service>

    <service verb="get" noun="RandomCategoryProduct">
        <description>
            Return Product that is selected randomly from products which are members of category of certain type.
        </description>
        <in-parameters>
            <parameter name="productCategoryTypeEnumId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="product"/>
        </out-parameters>
        <actions>
            <script>
                import org.moqui.context.ExecutionContext
                import org.moqui.entity.EntityCondition
                ExecutionContext ec = context.ec

                def categories = ec.entity.find("mantle.product.category.ProductCategory").condition("productCategoryTypeEnumId", productCategoryTypeEnumId).list()
                if (!categories) {
                    return;
                }

                def productCategoryIds = []
                categories.each{category ->
                    productCategoryIds.add(category.productCategoryId)
                }

                // query list of products
                def products = ec.entity.find("mantle.product.category.ProductCategoryMemberProduct")
                    .conditionDate("fromDate", "thruDate", ec.user.nowTimestamp)
                    .condition("productCategoryId", EntityCondition.IN, productCategoryIds).distinct(true).list()
                if (!products) {
                    return;
                }

                Random gen = new Random(new Date().getTime())
                product = products.get(gen.nextInt(products.size()))
            </script>
        </actions>
    </service>

    <service verb="get" noun="CategoryProducts">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="priceUomId"/>
            <parameter name="locale"/>
            <parameter name="orderBy" default-value="sequenceNum"/>
            <parameter name="pageIndex" default="0"/>
            <parameter name="pageSize" default="100"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productList" type="List"><parameter name="productInfo" type="Map">
                <parameter name="productId"/><parameter name="pseudoId"/><parameter name="productName"/><parameter name="description"/>
                <parameter name="price" type="BigDecimal"/><parameter name="listPrice" type="BigDecimal"/><parameter name="priceUomId"/>
                <parameter name="sequenceNum" type="Long"/>
                <parameter name="smallImageInfo" type="Map"/><parameter name="mediumImageInfo" type="Map"/>
            </parameter></parameter>
            <parameter name="productList" type="List"><parameter name="document" type="Map"/></parameter>
            <parameter name="productListCount" type="Integer"><description>The total count of hits, not just the
                limited number returned.</description></parameter>
            <parameter name="productListPageIndex" type="Integer"/>
            <parameter name="productListPageSize" type="Integer"/>
            <parameter name="productListPageMaxIndex" type="Integer"/>
            <parameter name="productListPageRangeLow" type="Integer"/>
            <parameter name="productListPageRangeHigh" type="Integer"/>
        </out-parameters>
        <actions>
            <service-call name="pos.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <if condition="productStoreId">
                <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore" cache="true"/>
                <if condition="!priceUomId"><set field="priceUomId" from="productStore?.defaultCurrencyUomId"/></if>
                <set field="vendorPartyId" from="productStore?.organizationPartyId"/>
            </if>

            <!-- get entire cached list then paginate, for huge numbers of products in a category this is a bad approach (such sites should probably be purely search based) -->
            <!-- use the name 'productList' so pagination out-parameters are created automatically -->
            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productList" cache="true">
                <search-form-inputs default-order-by="${orderBy}"/>
                <date-filter/><econdition field-name="productCategoryId"/>
            </entity-find>
            <set field="pcmList" from="productList"/>

            <set field="productList" from="[]"/>
            <iterate list="pcmList" entry="pcmp">
                <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true">
                    <field-map field-name="productId" from="pcmp.productId"/></entity-find-one>

                <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceMap" out-map-add-to-existing="false"
                        in-map="[productId:pcmp.productId, priceUomId:priceUomId, productStoreId:productStoreId,
                                vendorPartyId:vendorPartyId, customerPartyId:customerPartyId]"/>

                <set field="smallImageInfo" from="null"/>
                <set field="mediumImageInfo" from="null"/>
                <entity-find entity-name="mantle.product.ProductContent" list="productContentList" cache="true">
                    <date-filter/><econdition field-name="productId" from="pcmp.productId"/>
                    <order-by field-name="sequenceNum,-fromDate"/>
                </entity-find>
                <if condition="locale">
                    <!-- filter after by locale to streamline cached find -->
                    <set field="langLocale" from="locale.contains('_') ? locale.substring(locale.indexOf('_')) : null"/>
                    <set field="productContentList" from="productContentList.findAll({ it.locale == null || it.locale == locale || it.locale == langLocale })"/>
                </if>
                <if condition="productContentList">
                    <!-- medium can be PcntImageMedium or PcntImageLarge -->
                    <set field="mediumImageInfo" from="productContentList.find({ 'PcntImageMedium'.equals(it.productContentTypeEnumId) })"/>
                    <if condition="mediumImageInfo == null">
                        <set field="mediumImageInfo" from="productContentList.find({ 'PcntImageLarge'.equals(it.productContentTypeEnumId) })"/></if>
                    <!-- small can be PcntImageSmall or from medium we just looked up -->
                    <set field="smallImageInfo" from="productContentList.find({ 'PcntImageSmall'.equals(it.productContentTypeEnumId) })"/>
                    <if condition="smallImageInfo == null"><set field="smallImageInfo" from="mediumImageInfo"/></if>
                </if>

                <script>productList.add([productId:pcmp.productId, pseudoId:product.pseudoId, productName:product.productName,
                        description:product.description, price:priceMap.price, listPrice:priceMap.listPrice, priceUomId:priceMap.priceUomId,
                        sequenceNum:pcmp.sequenceNum, smallImageInfo:smallImageInfo, mediumImageInfo:mediumImageInfo])</script>
            </iterate>
        </actions>
    </service>

    <service verb="find" noun="CurrentPromoProduct">
        <description>
            Randomly select on of the products that have current price active and this current price is different
            then list price.
        </description>
        <in-parameters>
            <parameter name="productStoreId"/>
            <parameter name="priceUomId" default-value="USD"/>
        </in-parameters>
        <out-parameters>
            <parameter name="product"/>
        </out-parameters>
        <actions>
            <set field="currentPricesConds"
                    from="[pricePurposeEnumId:'PppPurchase',priceTypeEnumId:'PptCurrent',priceUomId:priceUomId]"/>
            <if condition="productStoreId">
                <set field="currentPricesConds.productStoreId" from="productStoreId"/>
            </if>
            <entity-find entity-name="mantle.product.ProductPrice" list="currentPrices" cache="true">
                <econdition-object field="currentPricesConds"/>
                <date-filter/>
                <order-by field-name="productId"/><order-by field-name="-fromDate"/>
            </entity-find>
            <script><![CDATA[
                processedProducts = [] as Set
                def productCandidates = []

                if (!currentPrices) {
                    return
                }

                for (EntityValue productPrice : currentPrices) {
                    if (processedProducts.contains(productPrice.productId)) continue;
                    def srvcParams = [productId:productPrice.productId, priceUomId:priceUomId, productStoreId:productStoreId]
                    def prices = ec.service.sync().name('mantle.product.PriceServices.get#ProductPrice').parameters(srvcParams).call()
                    if (prices.listPrice > 0 && prices.listPrice != prices.price) {
                        productCandidates.add(productPrice.productId);
                    }
                }

                if (productCandidates) {
                    Random gen = new Random(new Date().getTime())
                    def productId = productCandidates.get(gen.nextInt(productCandidates.size()))
                    product = ec.entity.find("mantle.product.Product").condition("productId", productId).one()
                }
            ]]></script>
        </actions>
    </service>

    <service verb="get" noun="CatalogProductId">
        <description>
            If product ID on input is a variant product then this service find associated virtual product
            and return its ID. Otherwise just return input ID. This service is used to build url to product
            in catalog. We cannot use variant product id exactly because variants are not browsable.
        </description>
        <in-parameters>
            <parameter name="productId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productId"/>
        </out-parameters>
        <actions>
            <if condition="productId">
                <entity-find entity-name="mantle.product.ProductAssoc" list="productAssocs">
                    <date-filter/>
                    <econdition field-name="toProductId" from="productId"/>
                    <econdition field-name="productAssocTypeEnumId" value="PatVariant"/>
                </entity-find>
                <if condition="productAssocs">
                    <set field="productId" from="productAssocs.get(0).productId"/>
                </if>
            </if>
        </actions>
    </service>

    <service verb="get" noun="Products">
        <in-parameters>
            <parameter name="productStoreId" required="true"/>
            <parameter name="includeDiscontinuedProducts" type="Boolean" default-value="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="data" type="List"></parameter>
        </out-parameters>
        <actions>
            <!-- Fetch vendorPartyId  -->
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId"/>
            </entity-find-one>
            <set field="vendorPartyId" from="productStore?.organizationPartyId"/>

            <entity-find entity-name="mantle.product.store.ProductStoreProduct" list="productStoreProductList">
                <econdition field-name="productStoreId"/>
            </entity-find>
            <if condition="productStoreProductList == null"><return error="true" message="Product not found with Store ID ${productStoreId}"/></if>

            <script>data = [];</script>
            <iterate list="productStoreProductList" entry="productStoreProduct">
                <entity-find-one entity-name="mantle.product.Product" value-field="product">
                    <field-map field-name="productId" from="productStoreProduct.productId"/>
                </entity-find-one>

                <if condition="product.productTypeEnumId == 'PtAsset'">
                    <if condition="includeDiscontinuedProducts">
                        <script>productInfoMap = [:]</script>
                        <service-call name="pos.ProductServices.get#ProductInfo" in-map="[productId: product.productId, productStoreId: productStoreId, vendorPartyId: vendorPartyId]" out-map="productInfo"/>
                        <script>
                            data.add(productInfo.productInfoMap)
                        </script>
                        <else>
                            <entity-find entity-name="mantle.product.Product" list="productList">
                                <econdition field-name="productId" from="product?.productId"/>
                                <econdition field-name="salesDiscontinuationDate" operator="is-null"/>
                            </entity-find>
                            <if condition="productList">
                                <script>productInfoMap = [:]</script>
                                <service-call name="pos.ProductServices.get#ProductInfo" in-map="[productId:productList[0].productId, productStoreId: productStoreId, vendorPartyId: vendorPartyId]" out-map="productInfo"/>
                                <script>
                                    data.add(productInfo.productInfoMap)
                                </script>
                            </if>
                        </else>
                    </if>
                </if>
                <else>
                    <entity-find entity-name="mantle.product.ProductAssoc" list="childProducts">
                        <econdition field-name="productId" from="productStoreProduct.productId"/>
                        <econdition field-name="productAssocTypeEnumId" value="PatVariant"/>
                        <date-filter/>
                    </entity-find>
                    <iterate list="childProducts" entry="childProduct">
                        <if condition="includeDiscontinuedProducts">
                            <script>productInfoMap = [:]</script>
                            <service-call name="pos.ProductServices.get#ProductInfo" in-map="[productId: childProduct?.toProductId, productStoreId: productStoreId, vendorPartyId: vendorPartyId]" out-map="productInfo"/>
                            <script>
                                data.add(productInfo.productInfoMap)
                            </script>
                        <else>
                            <entity-find entity-name="mantle.product.Product" list="productList">
                                <econdition field-name="productId" from="childProduct?.toProductId"/>
                                <econdition field-name="salesDiscontinuationDate" operator="is-null"/>
                            </entity-find>
                            <if condition="productList">
                                <script>productInfoMap = [:]</script>
                                <service-call name="pos.ProductServices.get#ProductInfo" in-map="[productId:productList[0].productId, productStoreId: productStoreId, vendorPartyId: vendorPartyId]" out-map="productInfo"/>
                                <script>
                                    data.add(productInfo.productInfoMap)
                                </script>
                            </if>
                        </else>
                        </if>
                    </iterate>
                </else>
            </iterate>
        </actions>
    </service>
</services>
